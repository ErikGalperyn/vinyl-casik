const bcrypt = require('bcryptjs');
const db = require('../database');

// Helper: Check if using PostgreSQL
const isPostgres = () => db._isPostgres === true;
// Helper to choose placeholder for SQLite vs Postgres
const p = (n) => (isPostgres() ? `$${n}` : '?');

module.exports = {
  getAll: async () => {
    const stmt = db.prepare('SELECT id, username, role FROM users');
    const result = await stmt.all();
    return result || [];
  },
  
  getById: async (id) => {
    const stmt = db.prepare(`SELECT id, username, role FROM users WHERE id = ${p(1)}`);
    return await stmt.get(id);
  },
  
  getByUsername: async (username) => {
    const stmt = db.prepare(`SELECT * FROM users WHERE username = ${p(1)}`);
    return await stmt.get(username);
  },
  
  create: async (username, password, role = 'user') => {
    const existing = await module.exports.getByUsername(username);
    if (existing) return null;
    
    // UUID will be auto-generated by database (gen_random_uuid())
    // No need to pass id parameter
    const passwordHash = bcrypt.hashSync(password, 10);
    
    const stmt = db.prepare(`INSERT INTO users (username, password, role) VALUES (${p(1)}, ${p(2)}, ${p(3)}) RETURNING id, username, role`);
    const result = await stmt.get(username, passwordHash, role);
    
    return result;
  },
  
  verifyPassword: (user, password) => {
    return bcrypt.compareSync(password, user.password);
  },
  
  update: async (id, updates) => {
    const user = await module.exports.getById(id);
    if (!user) return null;
    
    const { username, role } = updates;
    const stmt = db.prepare(`UPDATE users SET username = COALESCE(${p(1)}, username), role = COALESCE(${p(2)}, role) WHERE id = ${p(3)}`);
    await stmt.run(username, role, id);
    
    return await module.exports.getById(id);
  },
  
  delete: async (id) => {
    const stmt = db.prepare('DELETE FROM users WHERE id = $1');
    const result = await stmt.run(id);
    return result.changes > 0;
  }
};
